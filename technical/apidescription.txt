Animation API
	animDeclare = animation wrapper
			expects a namespace and as an optional perameter, a mix
			if not given, the program will ignore any other tags
			
	transformLang = language in which the transformation will take place
			will assume based on elements given. If a simple div or dom element, will do
			css transformations if given paths and polygons, will assume an svg transformation
			css
			svg	
				
	transformType = define the end points or the journey?
			functional(define a function of transformation)
			state(define start and end states and allow the program to interpolate)	
			
	type = specifies type of the animation
			expects 'repeatable', 'sequential', or 'oneshot'
			defaults to oneshot
			
	duration = entire time of the animation declared.
			this is an absolute(ms) time when setting at animDeclare level.
			this is absolute(ms) when referring to oneshots
			if given at a measure or note level, can be relative or absolute.
			if not given at a measure or note level, it assumes an even division of direct parent/child ratio
	

	division = given ONLY at animDeclare level or measure level
			if using a non-linear time division, can set the division here
			only affects notes/measures that are children of the element on which it was declared
			any children of these elements will have its parent as its divisor
				meter+duple
		  		meter+triple
		  		meter+simple
		  		meter+compound-num-num
		  		fib+collect
		  		fib+disperse
		  		fib+polarize	
		  		linear
		  		multiple+num
		  		none
		  		
	advancement = for chained animations only advancement controls when the measure changes.
			flow for automatic, 
			controlled for function, 
			wait(num) for a rest, 
			none to make it never advance
			
			
	anim = function to perform when called. 
			expects a string of preset functions, the resolution of which depends on the element on which it is called.
	
	animStart = if given, will define the starting condition
			will assume starting state as animStart otherwise
			if given with animEnd, it will assume an interpolation between the two
			if anim is given as well, it will assume NO interpolation and that the function controls the transformation
				unless it is a state based transformation, it will then assume that the extra anim 	
				to be a function called during its firing.
				if it is a functional transformation, it will assume to revert to this state at the end.
			
	animEnd	 = if given, will define the starting condition
			will assume starting state as animStart otherwise
			if given with animEnd, it will assume an interpolation between the two
			if anim is given as well, it will assume NO interpolation and that the function controls the transformation
				unless it is a state based transformation, it will then assume that the extra anim 	
				to be a function called during its firing.
				if it is a functional transformation, it will assume to revert to this state at the end.
				
	measureDeclare = a child of animDeclare that encompasses a division. 
			will assume the division to be one length unless told otherwise by the duration
			all children within a measure will share this division.
			
////noteSync = grouping pattern of notes to be fired.
////////////if no note sync is declared, it will assume that the notes have NO synchronization.
////////////and are supposed to be fired linearly.
////////////----Is this needed?
////////////////could be used to group notes that are not spatially next to eachother
////////////////---so could measures
////outdated////
////////////////

	order = used for ordering of the elements. 
			if given on a declare, will assume forward, backward, randomDecay, randomPersist, synchronize
			if given on an element in a declare will assume soft, hard, synchronize
				soft order leaves it to the element to fire as they appear in the dom
				hard order leaves it to the element to fire at a specific numeric index
				synchronize synchronizes it with any elements in its group.
				hard order will also achieve a synchronization
				
		
	permanence = used to determine endstate of the animation. 
				persist keep all changes or go to end state will hold till the end of the animation
				revert ignore all changes or go to beginning state will hold till end of the animation
				temporary keep all changes only till the end of the measure
				permanent keep all changes forever
				limit_num keep for this many animation counts. (will ignore num ammount of clear calls before activating again)
				****what does this mean in terms of functional vs state-driven transformations?